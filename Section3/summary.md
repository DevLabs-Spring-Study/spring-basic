## 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

### 새로운 할인 정책 개발
- 기획자가 새로운 할인 정책 추가를 요구? -> DIP, OCP를 못 지키는 문제점이 발생 : 문제점을 고치면서 스프링이 등장한 이유 => 이것이 스프링 컨테이너에서 동작하도록 할 것.
- VIP 할인 정책을 정액제 -> 퍼센트 방식으로 변경.

### 새로운 할인 정책 적용과 문제점
- 할인 정책 변경을 하려면 클라이언트인 OrderServiceImpl의 코드를 변경해야함. -> 역할과 구현을 충실하게 분리하였고, 다형성 활용, 인터페이스와 구현 객체도 분리했는데 OCP, DIP같은 객체지향 설계 원칙을 준수하지 않은 것이 됨.
- DIP : 클래스 의존 관계를 분석해봤을 떄, 추상뿐만 아니라 구체 클래스에도 의존하고 있다. -> DIP를 위반.
  - 추상(인터페이스) 의존: DiscountPolicy. 구체(구현) 클래스:FixDiscountPolicy, RatioDiscountPolicy
- OCP : 기능을 확장해서 변경하면 클라이언트 코드에 영향을 준다 -> OCP를 위반.
- 어떻게 문제를 해결할 것인가?
  - 클라이언트 코드인 OrderServiceImpl은 DiscountPolicy의 인터페이스뿐만 아니라 구체 클래스도 함께 의존함 => 그래서 구체 클래스를 변경할 때 클라이언트 코드도 함께 변경해야함. : DIP 위반이므로, 인터페이스에만 의존하도록 의존 관계를 변경해야함.
  - 인터페이스에만 의존하도록 코드 변경 -> 동작하지 않음. 구현체가 없는 코드를 어떻게 실행? => 누군가 클라이언트에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해줘야함.

### 관심사의 분리
- 본인의 역할에만 집중을 해야한다. 책임을 확실하게 분리해야함.
- 어플리케이션의 전체 동작 방식을 구현하기 위해 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스 **AppConfig** 생성.
- AppConfig가 실제 동작에 필요한 구현객체를 생성하면서, 인스턴스의 참조를 생성자를 통해서 주입해줌. => DIP 준수.
- 이를 통해 의존 관계에 대한 고민은 외부에 맡기고, 실행에만 집중할 수 있게 됨. => 객체를 생성하고 변경하는 역할과, 실행하는 역할히 명확히 분리됨. : DI(Dependency Injection), 의존관계 주입(의존성 주입)

### AppConfig 리팩터링
- 중복 제거.
- 역할과 구현 클래스가 한눈에 들어옴 -> 구성이 어떻게 되었는지 빠르게 파악할 수 있음.

### 새로운 구조와 할인 정책 적용
- 클라이언트 코드의 수정이 필요없음 : AppConfig만 변경해주면 됨. => 사용영역과 구성영역으로 앱이 분리가 됨.
- OCP, DIP 모두 준수하게 됨.

### 전체 흐름 정리
- 관심사 분리를 통해 구성 영역, 사용 영역으로 앱을 분리 => OCP, DIP 준수.

### 좋은 객체 지향 설계의 5가지 원칙의 적용
- SRP, DIP, OCP 적용
  - SRP : 클라이언트 객체가 다양한 책임 -> 구현 객체 생성, 연결하는 책임과 실행 책임을 분리
  - DIP : 클라이언트는 추상화에만 의존할 수 있도록 의존성 주입 활용. : AppConfig가 구체 클래스를 대신 생성해서 의존관계 주입해줌.
  - OCP : 다형성 사용하고 클라이언트가 DIP 지키면, OCP 가능성 열림 => 소프트웨어 요소를 확장해도 사용 영역의 변경은 닫혀 있다 (코드를 변경할 필요가 없다)

### IoC, DI, 그리고 컨테이너
- 제어의 역전, IoC(Inversion of Control)
  - 개발자가 호출하는 것이 아니라, 프레임워크가 대신 호출해준다 -> 제어권이 뒤바뀐다.
  - 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 구현 객체를 생성하고 연결하고 실행 : 프로그램의 제어 흐름을 스스로 조종. 개발자 입장에선 자연스러운 흐름임.
  - 반면, AppConfig : 구현 객체는 로직 실행 역할만 담당하고 프로그램의 제어 흐름은 AppConfig가 가져감 => 필요한 인터페이스를 호출하지만 어떤 구현 객체들이 실행될지는 모른다.
  - 프로그램의 제어 흐름을 외부에서 관리하는 것이 IoC.
  - 프레임워크 vs 라이브러리
    - 프레임워크가 코드를 제어하고 대신 실행하는 것 -> 프레임워크가 맞음.
    - 내가 작성한 코드가 직접 제어의 흐름을 담당 -> 라이브러리
- 의존관계 주입 DI(Dependency Injection)
  - 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계를 분리해서 생각해야 함.
    - 정적인 클래스 의존관계 : 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있음 -> 실행하지 않고도 분석 가능. : 실제 어떤 객체가 주입될지 알 수 없음.
    - 동적인 클래스 의존관계 : 어플리케이션 실행 시점에 실제 생성된 인스턴스의 참조가 연결된 의존 관계.
  - 어플리케이션 실행시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 DI.
  - 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
  - 의존관계 주입 사용 -> 클라이언트 코드 변겨하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있음. 또한, 정적인 클래스 의존관계를 변경하지 않고 동적인 인스턴스 의존관계를 쉽게 변경할 수 있음.
- IoC 컨테이너, DI 컨테이너
  - AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너 또는 DI 컨테이너라고 함.
  - 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 함. 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 함.

### 스프링으로 전환하기
- @Configuration : 설정 정보, 구성 정보. @Bean: 스프링 컨테이너에 등록됨.
- 스프링 컨테이너 : ApplicationContext
  - 기존에는 개발자가 AppConfig 사용, 직접 객체 생성하고 DI -> 스프링 컨테이너를 통해서 사용.
  - 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정 정보로 사용하고, @Bean이라 적힌 메서드를 모두 호출해서 반환된 스프링 컨테이너에 등록함 -> 이렇게 스프링 컨테이너에 등록된 객체를 **스프링 빈**이라 한다.
  - 스프링 빈은 @Bean이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용함.
  - 스프링 컨테이너를 통해서 필요한 스프링 빈 객체를 찾는다. -> applicationContext.getBean()을 사용해서 찾을 수 있음.
  - 스프링 컨테이너에 객체를 빈으로 등록(컨테이너에서 환경정보를 읽어와서 관리), 스프링 컨테이너에서 빈을 찾아서 사용하도록 변경된 것임.
  - 어떤 장점이 있는가? 컨테이너가 관리해줌으로 인해 할 수 있는 일이 어마어마함. DI등을 편리하게 해주도록 하는 범용의 프레임워크가 생기는 것.
